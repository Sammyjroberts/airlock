package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

type Method struct {
	Name       string
	Args       []Param
	Returns    []Param
	ReturnType string
}

type Param struct {
	Name string
	Type string
}

type Interface struct {
	Name    string
	Methods []Method
}

func main() {
	var inputFile, outputFile, interfaceName string
	flag.StringVar(&inputFile, "in", "", "Input file containing the interface")
	flag.StringVar(&outputFile, "out", "", "Output file for generated code")
	flag.StringVar(&interfaceName, "interface", "", "Name of the interface to implement")
	flag.Parse()

	if inputFile == "" || outputFile == "" || interfaceName == "" {
		log.Fatal("Please provide input file, output file, and interface name")
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, inputFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Error parsing input file: %v", err)
	}

	var iface Interface
	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		if typeSpec.Name.Name != interfaceName {
			return true
		}

		ifaceType, ok := typeSpec.Type.(*ast.InterfaceType)
		if !ok {
			return true
		}

		iface.Name = interfaceName
		for _, method := range ifaceType.Methods.List {
			methodType := method.Type.(*ast.FuncType)
			m := Method{
				Name: method.Names[0].Name,
			}

			// Process arguments
			if methodType.Params != nil {
				for i, param := range methodType.Params.List {
					paramType := getTypeString(param.Type)
					paramName := fmt.Sprintf("arg%d", i)
					if param.Names != nil {
						paramName = param.Names[0].Name
					}
					m.Args = append(m.Args, Param{Name: paramName, Type: paramType})
				}
			}

			// Process return values
			if methodType.Results != nil {
				for _, result := range methodType.Results.List {
					resultType := getTypeString(result.Type)
					if resultType != "error" {
						m.ReturnType = resultType
						m.Returns = append(m.Returns, Param{Type: resultType})
					}
				}
			}

			iface.Methods = append(iface.Methods, m)
		}
		return false
	})

	code := generateCode(iface)
	formatted, err := format.Source([]byte(code))
	if err != nil {
		log.Fatalf("Error formatting generated code: %v", err)
	}

	err = os.WriteFile(outputFile, formatted, 0644)
	if err != nil {
		log.Fatalf("Error writing output file: %v", err)
	}
}

func getTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + getTypeString(t.X)
	case *ast.ArrayType:
		return "[]" + getTypeString(t.Elt)
	case *ast.SelectorExpr:
		return fmt.Sprintf("%s.%s", getTypeString(t.X), t.Sel.Name)
	default:
		return fmt.Sprintf("%#v", expr)
	}
}

func generateCode(iface Interface) string {
	const tmpl = `// Code generated by airlock; DO NOT EDIT.
package main

import (
	"fmt"
)

type {{.Name}}Caller struct {
	proxyBase
}

func New{{.Name}}Caller(sockPath string) *{{.Name}}Caller {
	return &{{.Name}}Caller{
		proxyBase: proxyBase{sockPath: sockPath},
	}
}

{{range .Methods}}
func (c *{{$.Name}}Caller) {{.Name}}({{range $i, $arg := .Args}}{{if $i}}, {{end}}{{.Name}} {{.Type}}{{end}}) ({{if .Returns}}{{range $i, $ret := .Returns}}{{if $i}}, {{end}}{{.Type}}, {{end}}{{end}}error) {
	result, err := c.call("{{.Name}}", {{range $i, $arg := .Args}}{{if $i}}, {{end}}{{.Name}}{{end}})
	if err != nil {
		return {{if .Returns}}{{range .Returns}}{{zeroValue .Type}}, {{end}}{{end}}err
	}

	{{if .Returns}}
	typedResult, ok := result.({{.ReturnType}})
	if !ok {
		return {{range .Returns}}{{zeroValue .Type}}, {{end}}fmt.Errorf("unexpected result type: %T", result)
	}
	return typedResult, nil
	{{else}}
	return nil
	{{end}}
}
{{end}}`

	funcMap := template.FuncMap{
		"zeroValue": func(t string) string {
			switch t {
			case "int", "int64", "int32", "float64", "float32":
				return "0"
			case "string":
				return `""`
			case "bool":
				return "false"
			default:
				if strings.HasPrefix(t, "*") {
					return "nil"
				}
				return fmt.Sprintf("%s{}", t)
			}
		},
	}

	t := template.Must(template.New("caller").Funcs(funcMap).Parse(tmpl))
	var buf bytes.Buffer
	if err := t.Execute(&buf, iface); err != nil {
		log.Fatalf("Error executing template: %v", err)
	}

	return buf.String()
}
